/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */
package std.unittest.common

import std.collection.*

public interface KeyFor<T> {
    prop name: String
}

public struct KeyTags <: KeyFor<Array<String>> {
    public static prop tags: KeyTags {
        get() {
            KeyTags()
        }
    }

    public prop name: String {
        get() {
            "tags"
        }
    }
}

sealed abstract class ConfigurationKey <: Equatable<ConfigurationKey> & Hashable {
    protected ConfigurationKey(public let name: String) {}

    public override func hashCode(): Int64 {
        name.hashCode()
    }

    protected func equals(that: ConfigurationKey): Bool

    public override operator func ==(that: ConfigurationKey) {
        equals(that)
    }

    public override operator func !=(that: ConfigurationKey) {
        !equals(that)
    }
}

class TypedConfigurationKey<T> <: ConfigurationKey {
    TypedConfigurationKey(name: String) {
        super(name)
    }

    protected override func equals(that: ConfigurationKey): Bool {
        that is TypedConfigurationKey<T> && this.name == that.name
    }
}

extend ConfigurationKey {
    public static func create<T>(name: String): ConfigurationKey {
        TypedConfigurationKey<T>(name)
    }
}

/**
 * Configuration: the object that stores unittest configuration data produced by @Configure macro.
 * Configuration is a HashMap-like class, but instead of key and value types, it always have keys of type String,
 * and values of any given type
 */
public class Configuration <: ToString {
    private static let TAGS_CONCAT_KEY: ConfigurationKey = ConfigurationKey.create<Array<String>>("tags")

    private Configuration(
        private let storage: HashMap<ConfigurationKey, Any>
    ) {}

    /**
     * Default constructor: construct an empty configuration
     */
    public init() {
        this(HashMap<ConfigurationKey, Any>())
    }

    /**
     * Try to get value of type `T` using key `key`
     * @param key the key to look up in the configuration
     * @param T the type of the value to look up in the configuration
     * @returns Some(value) where value has type T if this configuration object contains
     *          a value of type `T` at key `key`
     *          None if there is no value for key `key` or the value is not of type `T`
     *
     * `key: KeyFor<T>` is generated by `@UnittestOption` macro. For example,
     * key for option `zxc` can be used as `KeyZxc.zxc`.
     */
    public func get<T>(key: KeyFor<T>): ?T {
        getByName<T>(key.name)
    }

    /**
     * Try to get value of type `T` using key `key`
     * @param key the key to look up in the configuration
     * @param T the type of the value to look up in the configuration
     * @returns Some(value) where value has type T if this configuration object contains
     *          a value of type `T` at key `key`
     *          None if there is no value for key `key` or the value is not of type `T`
     *
     */
    public func getByName<T>(name: String): ?T {
        let configurationKey = ConfigurationKey.create<T>(name)
        match (storage.get(configurationKey)) {
            case Some(v) => v as T
            case None => None<T>
        }
    }

    /**
     * Set the key `key` to value `value` in this configuration object for type `T`
     * @param key the key to look up in the configuration
     * @param value the value to put into the configuration by key `key`
     * @param T the type of the value
     * @returns Unit
     *
     * `key: KeyFor<T>` is generated by `@UnittestOption` macro. For example,
     * key for option `zxc` can be used as `KeyZxc.zxc`.
     */
    public func set<T>(key: KeyFor<T>, value: T): Unit {
        let configurationKey = checkOptionValueAndGetConfigurationKey(key, value)
        storage[configurationKey] = value
    }

    /**
     * Set the key `key` to value `value` in this configuration object for type `T`
     * @param key the key to look up in the configuration
     * @param value the value to put into the configuration by key `key`
     * @param T the type of the value
     * @returns Unit
     */
    public func setByName<T>(name: String, value: T): Unit {
        let configurationKey = checkOptionValueByNameAndGetConfigurationKey(name, value)
        storage[configurationKey] = value
    }

    /**
     * Remove the key `key` in this configuration object for type `T`
     * Does not remove other v
     * @param key the key to look up in the configuration
     * @param T the type of the value
     * @returns Some(v) holding existing value if this key with this type is in the configuration
     *          None otherwise
     *
     * `key: KeyFor<T>` is generated by `@UnittestOption` macro. For example,
     * key for option `zxc` can be used as `KeyZxc.zxc`.
     */
    public func remove<T>(key: KeyFor<T>): ?T {
        removeByName(key.name)
    }

    /**
     * Remove the key `key` in this configuration object for type `T`
     * Does not remove other v
     * @param key the key to look up in the configuration
     * @param T the type of the value
     * @returns Some(v) holding existing value if this key with this type is in the configuration
               None otherwise
     */
    public func removeByName<T>(key: String): ?T {
        let configurationKey = ConfigurationKey.create<T>(key)
        match (storage.remove(configurationKey)) {
            case Some(any) => any as T
            case None => None<T>
        }
    }
    /**
     * Clone this configuration object
     * @returns new Configuration object with the same keys and values as this one
     */
    public func clone(): Configuration {
        Configuration(storage.clone())
    }

    /**
     * Printable representation of this configuration object
     * For entries that implement ToString, uses it
     * For entries that do not implement ToString, displays '<value not printable>'
     */
    public func toString(): String {
        func printEntry(sb: StringBuilder, entry: (ConfigurationKey, Any)) {
            let (k, v) = entry
            sb.append(k.name)
            sb.append(":")
            sb.append(toStringOrPlaceholder(v))
        }
        let sb = StringBuilder("Configuration(")
        let storageIterator = storage.iterator()
        match (storageIterator.next()) {
            case None => return "Configuration()"
            case Some(entry) => printEntry(sb, entry)
        }
        for (entry in storageIterator) {
            sb.append(",")
            printEntry(sb, entry)
        }
        sb.append(")")
        return sb.toString()
    }

    // child has priority over values in parent
    public static func merge(parent: Configuration, child: Configuration): Configuration {
        let clone = parent.clone()
        for ((k, v) in child.storage) {
            if (k.equals(TAGS_CONCAT_KEY)) {
                // 08.08.2024. This was the only case which had to be merged differently
                let typedV = v as Array<String> ?? Array()
                let toPut = typedV |> concat(clone.get(KeyTags.tags) ?? Array()) |> collectHashSet
                clone.storage.add(k, toPut.toArray())
            } else {
                clone.storage.add(k, v)
            }
        }
        clone
    }
}
