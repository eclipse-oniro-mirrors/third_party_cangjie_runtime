/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */
macro package std.unittest.testmacro

import std.ast.*
import std.collection.*
import std.unittest.common.shieldEscapeSeq
import std.unicode.*

public macro PowerAssert(input: Tokens): Tokens {
    let (parsedExpr, isImplicitEquality) = match (parseCommaSeparatedExpressions(input)) {
        case args where args.size == 1 =>
            (args[0], false)
        case args where args.size == 2 =>
            let left = args[0].toTokens()
            let right = args[1].toTokens()
            /* Wrap operands to respect op precedence. */
            (quote(($left) == ($right)) |> parseExpr, true)
        case _ => throw MacroException(
            "Invalid syntax for @PowerAssert: use either @PowerAssert(a, b) or @PowerAssert(b)")
    }

    let (exprView, wrappedExpr) = PowerAssertWrapper.wrapNode(parsedExpr, isImplicitEquality: isImplicitEquality)
    /*
     We use a self-invoked lambda because Cangjie doesn't support blocks, and it's a short way to create a new lexical scope,
     self-invoked lambdas are also optimised by the compiler not to have call actually,
     due to this, for example, capturing mutable variables is allowed by the Cangjie compiler front-end.
     */
    return quote(
        { $(PowerAssertWrapper.variableName): PowerAssertDiagramBuilder =>
            $(PowerAssertWrapper.variableName).$(PowerAssertWrapper.writeTestResult)($wrappedExpr)
        }(PowerAssertDiagramBuilder($(exprView.asCodeInStringLiteral())))
    )
}

private abstract class PowerAssertWrapper <: Visitor {
    // Local variable name to store PowerAssertDiagramBuilder instance
    static let variableName = Token(TokenKind.IDENTIFIER, "pa__")

    // Shortcuts for PowerAssertDiagramBuilder methods
    static let handleException = Token(TokenKind.IDENTIFIER, "h")
    static let writeTestResult = Token(TokenKind.IDENTIFIER, "w")
    static let recordValue = Token(TokenKind.IDENTIFIER, "r")

    prop isTopLevel: Bool {
        get() {
            match (visitorParams) {
                case Some(p) => p.isTopLevel
                case _ => false
            }
        }
    }

    protected func wrap(_: IsExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: AsExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: LitConstExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: UnaryExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: BinaryExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: ParenExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: CallExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: RefExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: ReturnExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: AssignExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: MemberAccess, wrapper: SeqWrapper): Unit
    protected func wrap(_: IfExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: LetPatternExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: MatchExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: WhileExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: LambdaExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: SpawnExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: SynchronizedExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: TrailingClosureExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: TypeConvExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: ForInExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: PrimitiveTypeExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: ArrayLiteral, wrapper: SeqWrapper): Unit
    protected func wrap(_: TupleLiteral, wrapper: SeqWrapper): Unit
    protected func wrap(_: SubscriptExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: RangeExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: Block, wrapper: SeqWrapper): Unit
    protected func wrap(_: DoWhileExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: JumpExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: IncOrDecExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: TryExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: ThrowExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: OptionalExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: WildcardExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: VArrayExpr, wrapper: SeqWrapper): Unit
    protected func wrap(_: FuncDecl, wrapper: SeqWrapper): Unit
    protected func wrap(_: VarDecl, wrapper: SeqWrapper): Unit
    protected func wrap(_: FuncParam, wrapper: SeqWrapper): Unit
    protected func wrap(_: RefType, wrapper: SeqWrapper): Unit
    protected func wrap(_: PrimitiveType, wrapper: SeqWrapper): Unit
    protected func wrap(_: FuncType, wrapper: SeqWrapper): Unit
    protected func wrap(_: ThisType, wrapper: SeqWrapper): Unit
    protected func wrap(_: ParenType, wrapper: SeqWrapper): Unit
    protected func wrap(_: QualifiedType, wrapper: SeqWrapper): Unit
    protected func wrap(_: PrefixType, wrapper: SeqWrapper): Unit
    protected func wrap(_: TupleType, wrapper: SeqWrapper): Unit
    protected func wrap(_: VArrayType, wrapper: SeqWrapper): Unit
    protected func wrap(_: ConstPattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: WildcardPattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: VarPattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: VarOrEnumPattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: ExceptTypePattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: TypePattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: EnumPattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: TuplePattern, wrapper: SeqWrapper): Unit
    protected func wrap(_: GenericParam, wrapper: SeqWrapper): Unit
    protected func wrap(_: GenericConstraint, wrapper: SeqWrapper): Unit
    protected func wrap(_: MatchCase, wrapper: SeqWrapper): Unit
    protected func wrap(_: Argument, wrapper: SeqWrapper): Unit
    protected func wrap(_: Modifier, wrapper: SeqWrapper): Unit

    protected override func visit(expr: IsExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: AsExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: LitConstExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: UnaryExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: BinaryExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: ParenExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: CallExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: RefExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: ReturnExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: AssignExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: MemberAccess): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: IfExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: LetPatternExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: MatchExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: WhileExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: LambdaExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: SpawnExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: SynchronizedExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: TrailingClosureExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: TypeConvExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: ForInExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: PrimitiveTypeExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: ArrayLiteral): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: TupleLiteral): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: SubscriptExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: RangeExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: Block): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: DoWhileExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: JumpExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: IncOrDecExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: TryExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: ThrowExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: OptionalExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: WildcardExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(expr: VArrayExpr): Unit { wrap { w => wrap(expr, w) } }
    protected override func visit(decl: FuncDecl): Unit { wrap { w => wrap(decl, w) } }
    protected override func visit(decl: VarDecl): Unit { wrap { w => wrap(decl, w) } }
    protected override func visit(decl: FuncParam): Unit { wrap { w => wrap(decl, w) } }
    protected override func visit(node: RefType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: PrimitiveType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: FuncType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: ThisType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: ParenType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: QualifiedType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: PrefixType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: TupleType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: VArrayType): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(pattern: ConstPattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: WildcardPattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: VarPattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: VarOrEnumPattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: ExceptTypePattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: TypePattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: EnumPattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(pattern: TuplePattern): Unit { wrap { w => wrap(pattern, w) } }
    protected override func visit(node: GenericParam): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: GenericConstraint): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: MatchCase): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: Argument): Unit { wrap { w => wrap(node, w) } }
    protected override func visit(node: Modifier): Unit { wrap { w => wrap(node, w) } }

    protected func wrapTryCatch(tokensToWrap: Tokens, expr: String, position!: Int64) {
        // Couldn't pass $tokensToWrap as a lambda because it may capture mutable variables
        quote(
            try {
                $tokensToWrap
            } catch (e: Exception) {
                $variableName.$handleException(e, $(expr.asCodeInStringLiteral()), $position)
            }
        )
    }

    private func wrapRecordValue(tokensToWrap: Tokens, expr: String, position!: Int64) {
        quote($variableName.$recordValue($tokensToWrap, $(expr.asCodeInStringLiteral()), $position))
    }

    private func getWrappingCall(wrappedTokens: Tokens, expr: String, params: VisitorParams) {
        if (!params.wrapItself) {
            return wrappedTokens
        }
        let tryCatchWrapped = wrapTryCatch(wrappedTokens, expr, position: params.position)

        if (params.isTopLevel) {
            // We don't record a top-level value because it equals to false indeed
            tryCatchWrapped
        } else {
            wrapRecordValue(tryCatchWrapped, expr, position: params.position)
        }
    }

    private func wrap(wrapper: (SeqWrapper) -> Unit) {
        let params = visitorParams.getOrThrow() // @see [visitorParams]

        let wrapped = wrapSeq(params.position) { w => wrapper(w) }
        let wrappedTokens = getWrappingCall(wrapped.wrapped, wrapped.exprView, params)
        visitorResult = VisitorResult(wrapped: wrappedTokens, exprView: wrapped.exprView) // @see [visitorResult]
        breakTraverse()
    }

    private func wrapSeq(position: Int64, action: (SeqWrapper) -> Unit): VisitorResult {
        let seqWrapper = SeqWrapper(
            position,
            wrapper: traverse,
            wrapTryCatch: { tokens: Tokens, view: String, position: Int64 =>
                wrapTryCatch(tokens, view, position: position)
            }
        )

        action(seqWrapper)
        seqWrapper.result
    }

    /**
     * Node visit params that passed implicitly during traversal due to the lack of accepting visitor.
     * Note: May cause sync errors in in case of `Visitor` becomes concurrent.
     * Should not be used directly.
     */
    private var visitorParams: ?VisitorParams = None

    /**
     * Node visit result that returns implicitly during traversal due to the lack of returning visitor.
     * Note: May cause sync errors in in case of `Visitor` becomes concurrent.
     * Should not be used directly.
     */
    private var visitorResult: ?VisitorResult = None

    private func traverse(node: Node, params!: VisitorParams): VisitorResult {
        visitorParams = params.copy(wrapItself: shouldWrapItself(node, params.wrapItself))
        node.traverse(this)
        let result = visitorResult.getOrThrow()
        visitorParams = None
        result
    }

    static func wrapNode(node: Node, isImplicitEquality!: Bool): (String, Tokens) {
        let wrapper = PowerAssertWrapperImpl(hasImplicitTopLevelEquality: isImplicitEquality)
        let result = wrapper.traverse(node, params: VisitorParams(isTopLevel: true))
        (result.exprView, result.wrapped)
    }
}

private class SeqWrapper {
    private let resultBuilder = VisitResultBuilder()
    private var pos: Int64

    SeqWrapper(
        initialPosition: Int64,
        let wrapper!: (node: Node, params: VisitorParams) -> VisitorResult,
        let wrapTryCatch!: (tokens: Tokens, view: String, position: Int64) -> Tokens
    ) {
        this.pos = initialPosition
    }

    func wrap(node: Node, wrapItself!: Bool = true): Unit {
        let result = wrapper(node, VisitorParams(wrapItself: wrapItself, position: pos))
        pos += resultBuilder.append(result)
    }

    func wrap(tokens: Tokens, view!: String = tokens.toString(), padBefore!: Bool = true, padAfter!: Bool = true): Unit {
        pos += resultBuilder.append(tokens, view: view, padBefore: padBefore, padAfter: padAfter)
    }

    func wrap(token: Token, padBefore!: Bool = true, padAfter!: Bool = true): Unit {
        wrap(token.toTokens(), padBefore: padBefore, padAfter: padAfter)
    }

    func wrap<T>(
        nodes: ArrayList<T>,
        delimiter!: Token = Token(COMMA),
        padBefore!: Bool = false,
        padAfter!: Bool = true,
        wrapNodes!: Bool = true
    ) where T <: Node {
        for ((i, node) in nodes |> enumerate) {
            wrap(node, wrapItself: wrapNodes)
            if (i != nodes.size - 1) {
                wrap(delimiter, padBefore: padBefore, padAfter: padAfter)
            }
        }
    }

    func space() {
        pos += resultBuilder.append(" ", padBefore: false, padAfter: false)
    }

    func catchNoWrapping(node: Node) {
        let nodeView = wrapper(node, VisitorParams(wrapItself: false, position: pos)).exprView
        let isBlock = node is Block

        let nodeTokens = match (node) {
            case block: Block where block.hasLCurl => block.toTokensWithoutBraces()
            case _ => node.toTokens()
        }
        let catchingTokens = wrapTryCatch(nodeTokens, nodeView, pos)
        let wrappedTokens = match (isBlock) {
            case true => quote({ $(catchingTokens) })
            case _ => catchingTokens
        }
        pos += resultBuilder.append(wrappedTokens, view: nodeView, padBefore: false, padAfter: false)
    }

    prop result: VisitorResult {
        get() {
            resultBuilder.build()
        }
    }
}

private class PowerAssertWrapperImpl <: PowerAssertWrapper {
    PowerAssertWrapperImpl(let hasImplicitTopLevelEquality!: Bool) {}

    protected override func wrap(expr: IsExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.expr)
        wrapper.wrap(expr.keyword)
        wrapper.wrap(expr.shiftType)
    }

    protected override func wrap(expr: AsExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.expr)
        wrapper.wrap(expr.keyword)
        wrapper.wrap(expr.shiftType)
    }

    protected override func wrap(expr: LitConstExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: UnaryExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.op, padBefore: false, padAfter: false)
        wrapper.wrap(expr.expr)
    }

    protected override func wrap(expr: BinaryExpr, wrapper: SeqWrapper) {
        /**
         * Eliminate parenthesis on expressions implicitly wrapped on top-level.
         */
        let lexpr = match (expr.leftExpr) {
            case parenExpr: ParenExpr where isTopLevel && hasImplicitTopLevelEquality => parenExpr.parenthesizedExpr
            case other => other
        }

        let rexpr = match (expr.rightExpr) {
            case parenExpr: ParenExpr where isTopLevel && hasImplicitTopLevelEquality => parenExpr.parenthesizedExpr
            case other => other
        }

        wrapper.wrap(lexpr)
        wrapper.wrap(expr.op)
        wrapper.wrap(rexpr)
    }

    protected override func wrap(expr: ParenExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.parenthesizedExpr)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: CallExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.callFunc, wrapItself: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.arguments)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: RefExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
        if (!expr.typeArguments.isEmpty()) {
            wrapper.wrap(expr.lAngle, padBefore: false, padAfter: false)
            wrapper.wrap(expr.typeArguments, wrapNodes: false)
            wrapper.wrap(expr.rAngle, padBefore: false, padAfter: false)
        }
    }

    protected override func wrap(expr: ReturnExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.expr)
    }
    protected override func wrap(expr: AssignExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.leftExpr, wrapItself: false)
        wrapper.wrap(expr.assign)
        wrapper.wrap(expr.rightExpr)
    }

    protected override func wrap(expr: MemberAccess, wrapper: SeqWrapper) {
        if (let Some(refBaseExpr) <- (expr.baseExpr as RefExpr)) {
            let runes = refBaseExpr.identifier.value.toRuneArray()
            if (runes[0].isUpperCase() && (runes.size < 2 || !runes[1].isUpperCase())) {
                let tokens = refBaseExpr.toTokens()
                wrapper.wrap(tokens, padBefore: false, padAfter: false) // Assume as type
            } else {
                wrapper.wrap(expr.baseExpr) // Assume as expr
            }
        } else {
            wrapper.wrap(expr.baseExpr) // Assume as expr
        }

        wrapper.wrap(expr.dot, padBefore: false, padAfter: false)
        wrapper.wrap(expr.field, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: IfExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keywordI, padBefore: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.condition)
        wrapper.wrap(expr.rParen, padBefore: false)
        wrapper.wrap(expr.ifBlock)

        if (expr.hasElse) {
            wrapper.wrap(expr.keywordE)
            wrapper.wrap(expr.elseExpr)
        }
    }

    protected override func wrap(expr: LetPatternExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.pattern, wrapItself: false)
        wrapper.wrap(expr.backArrow)
        wrapper.wrap(expr.expr)
    }

    protected override func wrap(expr: MatchExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.selector)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.lBrace)
        wrapper.wrap(expr.matchCases, delimiter: Token(SEMI), wrapNodes: false)
        wrapper.wrap(expr.rBrace, padAfter: false)
    }

    protected override func wrap(expr: WhileExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.catchNoWrapping(expr.condition)
        wrapper.wrap(expr.rParen, padBefore: false)
        wrapper.catchNoWrapping(expr.block)
    }

    protected override func wrap(expr: LambdaExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.lBrace, padBefore: false)
        wrapper.wrap(expr.funcParams, wrapNodes: false)
        if (!expr.funcParams.isEmpty()) {
            wrapper.space()
        }
        if (expr.hasDoubleArrow) {
            wrapper.wrap(expr.doubleArrow, padBefore: false)
        }
        wrapper.wrap(expr.nodes, delimiter: Token(SEMI))
        wrapper.wrap(expr.rBrace, padAfter: false)
    }

    protected override func wrap(expr: SpawnExpr, wrapper: SeqWrapper) {
        let hasContext = expr.hasThreadContext
        wrapper.wrap(expr.keyword, padBefore: false, padAfter: !hasContext)
        if (hasContext) {
            wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
            wrapper.wrap(expr.threadContext)
            wrapper.wrap(expr.rParen, padBefore: false, padAfter: true)
        }

        wrapper.wrap(expr.lambdaExpr, wrapItself: false)
    }

    protected override func wrap(expr: SynchronizedExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.structuredMutex)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: true)
        wrapper.wrap(expr.block)
    }

    protected override func wrap(expr: TrailingClosureExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.expr, wrapItself: false)
        wrapper.space()
        wrapper.wrap(expr.lambdaExpr, wrapItself: false)
    }

    protected override func wrap(expr: TypeConvExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.targetType, wrapItself: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.expr)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: ForInExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keywordF, padBefore: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.pattern, wrapItself: false)
        wrapper.wrap(expr.keywordI)
        wrapper.catchNoWrapping(expr.expr)
        if (expr.hasGuard) {
            wrapper.wrap(expr.keywordW)
            wrapper.catchNoWrapping(expr.patternGuard)
        }
        wrapper.wrap(expr.rParen, padBefore: false)
        wrapper.catchNoWrapping(expr.block)
    }

    protected override func wrap(expr: PrimitiveTypeExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: ArrayLiteral, wrapper: SeqWrapper) {
        wrapper.wrap(expr.lSquare, padBefore: false, padAfter: false)
        wrapper.wrap(expr.elements)
        wrapper.wrap(expr.rSquare, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: TupleLiteral, wrapper: SeqWrapper) {
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.elements)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: SubscriptExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.baseExpr)
        wrapper.wrap(expr.lSquare, padBefore: false, padAfter: false)
        wrapper.wrap(expr.indexList)
        wrapper.wrap(expr.rSquare, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: RangeExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.start)
        wrapper.wrap(expr.op, padBefore: false, padAfter: false)
        wrapper.wrap(expr.end)
        if (expr.hasStep) {
            wrapper.wrap(expr.colon, padBefore: false, padAfter: false)
            wrapper.wrap(expr.step)
        }
    }

    protected override func wrap(expr: Block, wrapper: SeqWrapper) {
        if (expr.hasLCurl) {
            wrapper.wrap(expr.lBrace, padBefore: false)
        }

        wrapBodyNodes(expr.nodes, wrapper)

        if (expr.hasRCurl) {
            wrapper.wrap(expr.rBrace, padAfter: false)
        }
    }

    protected override func wrap(expr: DoWhileExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keywordD, padBefore: false)
        wrapper.catchNoWrapping(expr.block)
        wrapper.wrap(expr.keywordW, padAfter: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.catchNoWrapping(expr.condition)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: JumpExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: IncOrDecExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.expr, wrapItself: false)
        wrapper.wrap(expr.op, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: TryExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keywordT, padBefore: false)

        if (!expr.resourceSpec.isEmpty()) {
            wrapper.wrap(Token(LPAREN), padBefore: false, padAfter: false)
            wrapper.wrap(expr.resourceSpec, wrapNodes: false)
            wrapper.wrap(Token(RPAREN), padBefore: false)
        }

        wrapper.wrap(expr.tryBlock)

        for (i in 0..expr.catchBlocks.size) {
            wrapper.wrap(Token(CATCH))
            wrapper.wrap(Token(LPAREN), padBefore: false, padAfter: false)
            wrapper.wrap(expr.catchPatterns[i], wrapItself: false)
            wrapper.wrap(Token(RPAREN), padBefore: false)
            wrapper.wrap(expr.catchBlocks[i])
        }

        if (expr.hasFinally) {
            wrapper.wrap(expr.keywordF)
            wrapper.wrap(expr.finallyBlock)
        }
    }

    protected override func wrap(expr: ThrowExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.expr)
    }

    protected override func wrap(expr: OptionalExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.baseExpr)
        wrapper.wrap(expr.quest, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: WildcardExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: VArrayExpr, wrapper: SeqWrapper) {
        wrapper.wrap(expr.vArrayType, wrapItself: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.arguments)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: FuncDecl, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false)
        wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.funcParams)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)

        if (expr.hasReturnType) {
            wrapper.wrap(expr.colon, padBefore: false)
            wrapper.wrap(expr.declType)
        }
        wrapper.space()
        wrapper.catchNoWrapping(expr.block) // Do not record values from declaration. It could be called multiple times.
    }

    protected override func wrap(expr: VarDecl, wrapper: SeqWrapper) {
        if (expr.hasKeyword) {
            wrapper.wrap(expr.keyword, padBefore: false)
        }

        if (expr.hasPattern) {
            wrapper.wrap(expr.pattern, wrapItself: false)
        }

        if (expr.hasIdentifier) {
            wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
        }

        if (expr.hasDeclType) {
            wrapper.wrap(expr.colon, padBefore: false)
            wrapper.wrap(expr.declType, wrapItself: false)
        }

        if (expr.hasExpr) {
            wrapper.wrap(expr.assign)
            wrapper.wrap(expr.expr)
        }
    }

    protected override func wrap(expr: FuncParam, wrapper: SeqWrapper) {
        wrapper.wrap(expr.modifiers, wrapNodes: false)
        if (!expr.modifiers.isEmpty()) {
            wrapper.space()
        }

        if (expr.hasKeyword) {
            wrapper.wrap(expr.keyword, padBefore: false)
        }

        wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
        if (expr.isNamed) {
            wrapper.wrap(expr.not, padBefore: false, padAfter: false)
        }
        if (expr.hasType) {
            wrapper.wrap(Token(COLON), padBefore: false)
            wrapper.wrap(expr.paramType, wrapItself: false)
        }

        if (expr.hasValue) {
            wrapper.wrap(expr.assign)
            wrapper.wrap(expr.expr)
        }
    }

    protected override func wrap(node: RefType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: PrimitiveType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: FuncType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: ThisType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: ParenType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: QualifiedType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: PrefixType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: TupleType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(node: VArrayType, wrapper: SeqWrapper) {
        wrapper.wrap(node.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: ConstPattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.litConstExpr, wrapItself: false)
    }

    protected override func wrap(expr: WildcardPattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.wildcard, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: VarPattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: VarOrEnumPattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: ExceptTypePattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.pattern, wrapItself: false)
        wrapper.wrap(expr.colon, padBefore: false)
        wrapper.wrap(expr.types, delimiter: Token(BITOR), wrapNodes: false, padBefore: true, padAfter: true)
    }

    protected override func wrap(expr: TypePattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.pattern, wrapItself: false)
        wrapper.wrap(expr.colon, padBefore: false)
        wrapper.wrap(expr.patternType, wrapItself: false)
    }

    protected override func wrap(expr: EnumPattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.constructor, wrapItself: false)
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.patterns, wrapNodes: false)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: TuplePattern, wrapper: SeqWrapper) {
        wrapper.wrap(expr.lParen, padBefore: false, padAfter: false)
        wrapper.wrap(expr.patterns, wrapNodes: false)
        wrapper.wrap(expr.rParen, padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: GenericParam, wrapper: SeqWrapper) {
        if (expr.parameters.size > 0) {
            wrapper.wrap(expr.lAngle, padBefore: false, padAfter: false)
            for ((i, arg) in expr.parameters |> enumerate) {
                wrapper.wrap(arg, padBefore: false, padAfter: false)
                if (i != expr.parameters.size - 1) {
                    wrapper.wrap(Token(COMMA), padBefore: false, padAfter: false)
                }
            }
            wrapper.wrap(expr.rAngle, padBefore: false, padAfter: false)
        }
    }

    protected override func wrap(expr: GenericConstraint, wrapper: SeqWrapper) {
        wrapper.wrap(expr.toTokens(), padBefore: false, padAfter: false)
    }

    protected override func wrap(expr: MatchCase, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keywordC, padBefore: false)

        if (expr.hasExpr) {
            wrapper.wrap(expr.expr, wrapItself: false)
        }

        wrapper.wrap(expr.patterns, delimiter: Token(BITOR), wrapNodes: false, padBefore: true, padAfter: true)
        if (expr.hasGuard) {
            wrapper.wrap(expr.keywordW)
            wrapper.wrap(expr.patternGuard)
        }

        wrapper.wrap(expr.arrow)
        wrapper.wrap(expr.block)
    }

    protected override func wrap(expr: Argument, wrapper: SeqWrapper) {
        if (expr.hasKeyword) {
            wrapper.wrap(expr.keyword, padBefore: false)
        }

        if (expr.isNamed) {
            wrapper.wrap(expr.identifier, padBefore: false, padAfter: false)
            wrapper.wrap(Token(COLON), padBefore: false)
        }
        wrapper.wrap(expr.expr)
    }

    protected override func wrap(expr: Modifier, wrapper: SeqWrapper) {
        wrapper.wrap(expr.keyword, padBefore: false, padAfter: false)
    }

    private func wrapBodyNodes(nodes: ArrayList<Node>, wrapper: SeqWrapper): Unit {
        wrapper.wrap(nodes, delimiter: Token(SEMI), padBefore: false)
    }
}

private func shouldWrapItself(node: Node, fallback: Bool): Bool {
    match (node) {
        case _: Argument => false
        case _: Block => false
        case _: Decl => false
        case _: LetPatternExpr => false
        case _: LitConstExpr => false
        case _: OptionalExpr => false
        case _: ParenExpr => false
        case _: Pattern => false
        case _: ReturnExpr => false
        case _: TypeNode => false
        case _ => fallback
    }
}

private class VisitorParams {
    VisitorParams(let isTopLevel!: Bool = false, let position!: Int64 = 0, let wrapItself!: Bool = true) {}

    func copy(isTopLevel!: Bool = this.isTopLevel, position!: Int64 = this.position, wrapItself!: Bool = this.wrapItself) {
        VisitorParams(isTopLevel: isTopLevel, position: position, wrapItself: wrapItself)
    }
}

private class VisitorResult {
    VisitorResult(let wrapped!: Tokens, let exprView!: String) {}
}

private class VisitResultBuilder {
    private let view = StringBuilder()
    private let wrapped = Tokens()

    func build(): VisitorResult {
        VisitorResult(wrapped: wrapped, exprView: view.toString())
    }

    func append(result: VisitorResult) {
        wrapped.append(result.wrapped)
        view.append(result.exprView)
        result.exprView.size
    }

    /**
     * Returns the count of appended characters.
     */
    func append(view: String, padBefore!: Bool = true, padAfter!: Bool = true): Int64 {
        if (padBefore) { this.view.append(' ') }
        this.view.append(view)
        if (padAfter) { this.view.append(' ') }
        view.size + if (padBefore && padAfter) { 2 } else if (padBefore || padAfter) { 1 } else { 0 }
    }

    func append(tokens: Tokens, view!: String = tokens.toString(), padBefore!: Bool = true, padAfter!: Bool = true) {
        wrapped.append(tokens)
        append(view, padBefore: padBefore, padAfter: padAfter)
    }
}

extend IfExpr {
    prop hasElse: Bool {
        get() {
            keywordE.kind == TokenKind.ELSE
        }
    }
}

extend Block {
    prop hasLCurl: Bool {
        get() {
            lBrace.kind == TokenKind.LCURL
        }
    }

    prop hasRCurl: Bool {
        get() {
            rBrace.kind == TokenKind.RCURL
        }
    }

    func toTokensWithoutBraces(): Tokens {
        let tokens = Tokens()
        for (node in nodes) {
            tokens.append(node)
            tokens.append(Token(SEMI))
        }
        tokens
    }
}

extend MatchCase {
    prop hasGuard: Bool {
        get() {
            keywordW.kind == TokenKind.WHERE
        }
    }

    prop hasExpr: Bool {
        get() {
            try { expr; true } catch(_) { false }
        }
    }
}

extend SpawnExpr {
    prop hasThreadContext: Bool {
        get() {
            try { threadContext; true } catch(_) { false }
        }
    }
}

extend LambdaExpr {
    prop hasDoubleArrow: Bool {
        get() {
            doubleArrow.kind == TokenKind.DOUBLE_ARROW
        }
    }
}

extend ForInExpr {
    prop hasGuard: Bool {
        get() {
            try { patternGuard; true } catch(_) { false }
        }
    }
}

extend RangeExpr {
    prop hasStep: Bool {
        get() {
            try { step; true } catch(_) { false }
        }
    }
}

extend TryExpr {
    prop hasFinally: Bool {
        get() {
            try { finallyBlock; true } catch(_) { false }
        }
    }
}

extend FuncDecl {
    prop hasReturnType: Bool {
        get() {
            try { declType; true } catch(_) { false }
        }
    }
}

extend Decl {
    prop hasKeyword: Bool {
        get() {
            keyword.kind != TokenKind.ILLEGAL
        }
    }

    prop hasIdentifier: Bool {
        get() {
            identifier.kind != TokenKind.ILLEGAL
        }
    }
}

extend VarDecl {
    prop hasPattern: Bool {
        get() {
            try { pattern; true } catch (_) { false }
        }
    }

    prop hasDeclType: Bool {
        get() {
            try { declType; true } catch (_) { false }
        }
    }

    prop hasExpr: Bool {
        get() {
            try { expr; true } catch (_) { false }
        }
    }
}

extend FuncParam {
    prop hasValue: Bool {
        get() {
            try { expr; true } catch (_) { false }
        }
    }

    prop hasType: Bool {
        get() {
            paramType.toTokens().size != 0
        }
    }
}

extend Argument {
    prop isNamed: Bool {
        get() {
            try {
                this.identifier // identifier access throws exception if it is empty
                true
            } catch (e: ASTException) {
                false
            }
        }
    }

    prop hasKeyword: Bool {
        get() {
            keyword.kind != TokenKind.ILLEGAL
        }
    }
}

extend String {
    func asCodeInStringLiteral(): Token {
        Token(STRING_LITERAL, shieldEscapeSeq(this))
    }
}
