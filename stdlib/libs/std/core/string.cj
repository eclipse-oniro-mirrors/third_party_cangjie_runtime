/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package std.core

@Intrinsic
func vectorCompare32(arr1: RawArray<Byte>, offset1: Int64, arr2: RawArray<Byte>, offset2: Int64): Int64

@Intrinsic
func vectorIndexByte32(arr: RawArray<Byte>, offset: Int64, target: Byte): Int64

@When[backend == "cjnative"]
const UNICODE_TO_UTF8_MAX_LEN: Int64 = 4
@When[backend == "cjnative"]
@ConstSafe
const IS_SIMD_SUPPORTED: Bool = unsafe { CJ_CORE_CanUseSIMD() }
@When[backend == "cjnative"]
const VECTOR_OFFSET_32: Int64 = 32

@When[backend == "cjnative"]
@ConstSafe
public struct String <: Collection<Byte> & Comparable<String> & Hashable & ToString {
    let myData: RawArray<UInt8>
    let start: UInt32
    let length: UInt32

    public static const empty: String = String()

    /**
     * Constructors
     */

    // Create an empty string which is an empty sequence of character.
    @Frozen
    public const init() {
        (myData, start, length) = (EMPTY_UINT8_RAW_ARRAY, 0u32, 0u32)
    }

    @Frozen
    @OverflowWrapping
    public init(value: Array<Rune>) {
        if (value.size == 0) {
            (myData, start, length) = (EMPTY_UINT8_RAW_ARRAY, 0u32, 0u32)
            return
        }
        let data = RunesToUtf8Bytes.getBytes(value)
        if (data.size > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        this.myData = data.rawptr
        this.start = UInt32(data.start)
        this.length = UInt32(data.len)
    }

    @Frozen
    @OverflowWrapping
    public init(value: Collection<Rune>) {
        let data = RunesToUtf8Bytes.getBytes(value)
        if (data.size > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        this.myData = data.rawptr
        this.start = UInt32(data.start)
        this.length = UInt32(data.len)
    }

    @Frozen
    init(value: RawArray<UInt8>) {
        let len = arraySize(value)
        if (len > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        (myData, start, length) = (value, 0u32, UInt32(len))
    }

    @Frozen
    init(value: RawArray<UInt8>, start: UInt32, len: UInt32) {
        (this.myData, this.start, this.length) = (value, start, len)
    }

    /**
     * @throws IllegalMemoryException if memory alloc fails.
     */
    @Frozen
    init(ptr: CPointer<UInt8>, cSize: Int64) {
        if (cSize > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        if (cSize == 0) {
            (myData, start, length) = (EMPTY_UINT8_RAW_ARRAY, 0u32, 0u32)
        } else if (cSize < STRING_C_THRESHOLD) {
            this.myData = RawArray<UInt8>(cSize, repeat: 0)
            for (i in 0..cSize) {
                arraySetUnchecked(myData, i, unsafe { ptr.read(i) })
            }
            this.start = 0
            this.length = UInt32(cSize)
        } else {
            this.myData = RawArray<UInt8>(cSize, repeat: 0)
            unsafe {
                let itemP: CPointer<UInt8> = acquireRawData(myData)
                memcpy_s(itemP, UIntNative(cSize), ptr, UIntNative(cSize))
                releaseRawData(myData, itemP)
            }
            this.start = 0
            this.length = UInt32(cSize)
        }
    }

    @Frozen
    init(value: Array<UInt8>) {
        if (value.len > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        (myData, start, length) = (value.rawptr, UInt32(value.start), UInt32(value.len))
    }

    // Returns the byte at the specified index.
    @Frozen
    @OverflowWrapping
    public func get(index: Int64): Option<Byte> {
        if (UInt64(index) >= UInt64(length)) {
            return None
        }
        return arrayGetUnchecked(this.myData, Int64(this.start) + index)
    }

    @Frozen
    @OverflowWrapping
    internal func acquireRaw(): CPointer<UInt8> {
        unsafe { acquireRawData<UInt8>(this.myData) + Int64(this.start) }
    }

    @Frozen
    @OverflowWrapping
    internal func releaseRaw(ptr: CPointer<UInt8>): Unit {
        unsafe { releaseRawData<UInt8>(this.myData, ptr - Int64(start)) }
    }

    /**
     * Returns the sequence of characters in this string in the form of an array of characters.
     * @throws IllegalArgumentException if there is an invalid utf8 leading code
     *         in array `this.myData`.
     */
    @Frozen
    @OverflowWrapping
    public func toRuneArray(): Array<Rune> {
        let runeSize = utf8RuneSize(myData, Int64(start), Int64(length))
        let runes: Array<Rune> = Array<Rune>(runeSize, repeat: unsafe { zeroValue<Rune>() })
        var i: Int64 = Int64(start)
        var end: Int64 = Int64(start) + Int64(length)
        var j: Int64 = 0
        var utf8Size: Int64 = 0
        while (i < end) {
            (runes[j], utf8Size) = Rune.fromUtf8(myData, i, end)
            i = i + utf8Size
            j++
        }
        return runes
    }

    @Frozen
    public func toArray(): Array<Byte> {
        let newRawPtr = RawArray<UInt8>(this.size, repeat: 0)
        intrinsicBuiltInCopyTo<Byte>(this.myData, newRawPtr, Int64(this.start), 0, Int64(length))
        return Array<Byte>(newRawPtr, 0, size)
    }

    @Frozen
    public func toString(): String {
        return this
    }

    @Frozen
    public func iterator(): Iterator<Byte> {
        return StringByteIterator(StringIteratorData(unsafe { rawData() }))
    }

    @Frozen
    public func runes(): Iterator<Rune> {
        return StringRuneIterator(StringIteratorData(unsafe { rawData() }))
    }

    @Frozen
    public func lines(): Iterator<String> {
        return StringLineIterator(StringIteratorData(unsafe { rawData() }))
    }

    // Returns the byte counts of this string.
    @Frozen
    public prop size: Int64 {
        get() {
            Int64(length)
        }
    }

    // Returns true if and only if this string is an empty string.
    @Frozen
    public func isEmpty(): Bool {
        return length == 0
    }

    /**
     * Determine if the string is an Ascii string,
     * return true if there are no characters other than Ascii in the string,
     * return true if the string is empty.
     */
    @Frozen
    public func isAscii(): Bool {
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in size - 1..=0 : -1) {
            let b = arrayGetUnchecked(this.myData, Int64(start) + i)
            // ascii rune's most significant bit (MSB) is zero
            if ((b >> 7) == 1) {
                return false
            }
        }
        return true
    }

    @Frozen
    public func isAsciiBlank(): Bool {
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in size - 1..=0 : -1) {
            if (!arrayGetUnchecked(this.myData, Int64(start) + i).isAsciiWhiteSpace()) {
                return false
            }
        }
        return true
    }

    @Frozen
    public func clone(): String {
        let newRawPtr = RawArray<UInt8>(this.size, repeat: 0)
        intrinsicBuiltInCopyTo<UInt8>(this.myData, newRawPtr, Int64(start), 0, Int64(length))
        return String(newRawPtr, 0, length)
    }

    /**
     * Use wyhash to generate a hash value for a string.
     */
    @Frozen
    @OverflowWrapping
    public func hashCode(): Int64 {
        return Int64(wyhash(myData, Int64(start), Int64(length), 0))
    }

    /**
     * Construct a string from a utf8-compliant bytecode sequence
     * @Param utf8Data - UTF8 bytecode sequence
     * @throws IllegalArgumentException If the array is an invalid UTF8 sequence
     * @return a String
     */
    @Frozen
    public static func fromUtf8(utf8Data: Array<UInt8>): String {
        checkInvalid(utf8Data.rawptr, utf8Data.start, utf8Data.start + utf8Data.size)
        return String(utf8Data.clone())
    }

    @Frozen
    public unsafe func rawData(): Array<Byte> {
        return Array<Byte>(myData, Int64(start), Int64(length))
    }

    @Frozen
    public unsafe static func fromUtf8Unchecked(utf8Data: Array<UInt8>): String {
        return String(utf8Data.clone())
    }

    // Returns the index of the first occurrence of the specified byte.
    // Return `Option<Int64>.None` if the specified byte is absent.
    @Frozen
    public func indexOf(b: Byte): Option<Int64> {
        return match (indexOfImpl(b, 0)) {
            case -1 => None
            case val => Some(val)
        }
    }

    // Returns the index of the first occurrence of the specified byte at or after the specified index.
    // Returns `Option<Int64>.None` if the specified byte is absent at or after the specified index.
    @Frozen
    public func indexOf(b: Byte, fromIndex: Int64): Option<Int64> {
        if (fromIndex >= size) {
            return None
        }
        let start = if (fromIndex < 0) { 0 } else { fromIndex }
        return match (indexOfImpl(b, start)) {
            case -1 => None
            case val => Some(val)
        }
    }

    // The parameter `fromIndex` should be [0..size) and will not be checked
    // Returns -1 if the specified byte is absent
    @Frozen
    private func indexOfImpl(b: Byte, fromIndex: Int64): Int64 {
        return if (IS_SIMD_SUPPORTED) {
            indexOfFast(b, fromIndex)
        } else {
            indexOfCommon(b, fromIndex)
        }
    }

    @Frozen
    @OverflowWrapping
    private func indexOfCommon(b: Byte, fromIndex: Int64): Int64 {
        for (i in fromIndex..size) {
            if (arrayGetUnchecked(this.myData, Int64(start) + i) == b) {
                return i
            }
        }
        return -1
    }

    @Frozen
    @OverflowWrapping
    private func indexOfFast(b: Byte, fromIndex: Int64): Int64 {
        var i = fromIndex
        let rawptr = this.myData
        var begin = Int64(this.start) + i
        while (i + VECTOR_OFFSET_32 <= size) {
            let vecCmpRes: Int64 = vectorIndexByte32(rawptr, begin, b)
            // when any position byte is matched, return a value different from 32
            if (vecCmpRes != 32) {
                return i + vecCmpRes
            }
            i += VECTOR_OFFSET_32
            begin += VECTOR_OFFSET_32
        }

        for (j in i..size) {
            if (arrayGetUnchecked(this.myData, Int64(this.start) + j) == b) {
                return j
            }
        }
        return -1
    }

    // Returns the index of the first occurrence of the specified substring `str`.
    // Return `Option<Int64>.None` if `str` is absent.
    @Frozen
    public func indexOf(str: String): Option<Int64> {
        if (str.isEmpty()) {
            return Option<Int64>.Some(0)
        }
        if (str.size == 1) {
            return indexOf(arrayGetUnchecked(str.myData, Int64(str.start)))
        }
        var index: Int64 = indexOfString(str)
        if (index < 0) {
            return Option<Int64>.None
        }
        return Option<Int64>.Some(index)
    }

    // Returns the index of the first occurrence of the specified substring `str` at or after the specified index.
    // Return `Option<Int64>.None` if the specified string is absent at or after the specified index.
    @Frozen
    public func indexOf(str: String, fromIndex: Int64): Option<Int64> {
        if (str.length == 0) {
            if (fromIndex < 0) {
                return Option<Int64>.Some(0)
            } else if (fromIndex > size) {
                return Option<Int64>.None
            } else {
                return Option<Int64>.Some(fromIndex)
            }
        }
        if (str.size == 1) {
            return indexOf(arrayGetUnchecked(str.myData, Int64(str.start)), fromIndex)
        }
        if (fromIndex < 0) {
            return this.indexOf(str)
        } else if (fromIndex >= size) {
            return Option<Int64>.None
        }
        var index: Int64 = indexOfString(str, startIndex: fromIndex)
        if (index < 0) {
            return Option<Int64>.None
        }
        return Option<Int64>.Some(index)
    }

    // Returns the index of the last occurrence of the specified byte.
    // Return `Option<Int64>.None` if specified byte is absent.
    @Frozen
    public func lastIndexOf(b: Byte): Option<Int64> {
        return lastIndexOf(b, 0)
    }

    // Returns the index of the last occurrence of the specified byte at or after the specified index.
    // Return `Option<Int64>.None` if specified byte is absent at or after the specified index.
    @Frozen
    @OverflowWrapping
    public func lastIndexOf(b: Byte, fromIndex: Int64): Option<Int64> {
        if (fromIndex < 0) {
            return lastIndexOf(b, 0)
        } else if (fromIndex >= size) {
            return None
        }
        for (i in size - 1..=fromIndex : -1) {
            if (arrayGetUnchecked(myData, Int64(start) + i) == b) {
                return i
            }
        }
        return None
    }

    // Returns the index of the last occurrence of the specified substring `str`.
    // Return `Option<Int64>.None` if specified substring is absent.
    @Frozen
    public func lastIndexOf(str: String): Option<Int64> {
        if (str.isEmpty()) {
            return Option<Int64>.Some(size)
        }
        var index: Int64 = indexOfString(str, fromLast: true)
        if (index < 0) {
            return Option<Int64>.None
        }
        return Option<Int64>.Some(index)
    }

    // Returns the index of the last occurrence of the specified substring `str` at or after the specified index.
    // Return `Option<Int64>.None` if specified substring is absent at or after the specified index.
    // Search last substring from the beginning when 'fromIndex' is less than 0.
    @Frozen
    public func lastIndexOf(str: String, fromIndex: Int64): Option<Int64> {
        if (str.isEmpty()) {
            if (fromIndex > size) {
                return Option<Int64>.None
            } else {
                return Option<Int64>.Some(size)
            }
        }
        if (fromIndex < 0) {
            return this.lastIndexOf(str)
        } else if (fromIndex >= size) {
            return Option<Int64>.None
        }
        var index: Int64 = indexOfString(str, startIndex: fromIndex, fromLast: true)
        if (index < 0) {
            return Option<Int64>.None
        }
        return Option<Int64>.Some(index)
    }

    // Returns the number of non-overlapping occurrences of the given substring `str` in the string.
    // If `str` is an empty string, returns the number of Unicode code points in this string + 1.
    @Frozen
    @OverflowWrapping
    public func count(str: String): Int64 {
        if (str.length == 0) {
            return utf8RuneSize(myData, Int64(start), Int64(length)) + 1
        }
        unsafe {
            var ptr1: CPointer<UInt8> = this.acquireRaw()
            var ptr2: CPointer<UInt8> = str.acquireRaw()
            var res: Int64 = CJ_CORE_CountString(ptr1, ptr2, size, str.size)
            this.releaseRaw(ptr1)
            str.releaseRaw(ptr2)
            return res
        }
    }

    /**
     * @return an array of strings which are the result of separating this string using the specified
     *         separator. If the separator is not empty and is absent in this string, returns an array
     *         which only contains this string. If the separator is empty, split after each character.
     *         If both this string and separator are empty, returns an empty array.
     * @throws OutOfMemoryError if failed to call `this.splitOfString`.
     */
    @Frozen
    public func split(str: String, removeEmpty!: Bool = false): Array<String> {
        if (size == 0) {
            return EMPTY_STRING_ARRAY
        }
        return this.splitOfString(str, -1, removeEmpty)
    }

    /**
     * @return an array of strings which are the result of separating this string using the specified
     *         separator with maximum split number `maxSplits`.
     * @throws OutOfMemoryError if failed to call `this.splitOfString`.
     */
    @Frozen
    public func split(str: String, maxSplits: Int64, removeEmpty!: Bool = false): Array<String> {
        if (size == 0 || maxSplits == 0) {
            return EMPTY_STRING_ARRAY
        }
        return this.splitOfString(str, maxSplits, removeEmpty)
    }

    @Frozen
    public func lazySplit(str: String, removeEmpty!: Bool = false): Iterator<String> {
        if (size == 0) {
            return EMPTY_STRING_ARRAY.iterator()
        }
        return StringLazySplitIterator(unsafe { rawData() }, size, str, -1, removeEmpty)
    }

    @Frozen
    public func lazySplit(str: String, maxSplits: Int64, removeEmpty!: Bool = false): Iterator<String> {
        if (size == 0 || maxSplits == 0) {
            return EMPTY_STRING_ARRAY.iterator()
        }
        return StringLazySplitIterator(unsafe { rawData() }, size, str, maxSplits, removeEmpty)
    }

    @Frozen
    public func replace(old: String, new: String): String {
        if (size == 0) {
            if (old.size == 0) {
                return new
            } else {
                return this
            }
        }

        if (old.size == 0) {
            return insertString(new)
        } else {
            return replaceString(old, new)
        }
    }

    @Frozen
    @OverflowWrapping
    private func insertString(new: String): String {
        let newArr: Array<UInt8> = unsafe { new.rawData() }
        let newSize: Int64 = new.size
        var total: Int64 = this.count("")
        var countSize: Int64 = size + newSize * total
        if (countSize > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }
        var itemArray: Array<UInt8> = Array<UInt8>(countSize, repeat: 0)
        var start: Int64 = 0
        var oneSize: Int64 = 0
        var i: Int64 = 0
        itemArray[..newSize] = newArr[..newSize]
        i += newSize
        let data = unsafe { rawData() }
        while (start < size) {
            oneSize = Rune.utf8Size(data, start)
            itemArray[i..(i + oneSize)] = data[start..(start + oneSize)]
            i += oneSize
            itemArray[i..(i + newSize)] = newArr[..newSize]
            i += newSize
            start += oneSize
        }
        return String(itemArray)
    }

    @Frozen
    @OverflowWrapping
    private func replaceString(old: String, new: String): String {
        let oldSize: Int64 = old.size
        let newSize: Int64 = new.size
        var res: CPointer<Int64> = CPointer<Int64>()
        var indexes: CPointer<Int64> = CPointer<Int64>()
        var total: Int64 = 0
        unsafe {
            let org: CPointer<UInt8> = this.acquireRaw()
            let pat: CPointer<UInt8> = old.acquireRaw()
            res = CJ_CORE_CountAndIndexString(org, pat, size, oldSize)
            this.releaseRaw(org)
            old.releaseRaw(pat)
            if (res.isNull()) {
                throw OutOfMemoryError("Failed malloc in C code!")
            }
            total = res.read(0)
            indexes = res + 1
        }
        try {
            if (total == 0) {
                return this
            }
            let countSize: Int64 = size + (newSize - oldSize) * total
            if (countSize > Int64(UInt32.Max)) {
                throw IllegalArgumentException("The size of String is too large.")
            }
            var itemArray: Array<UInt8> = Array<UInt8>(countSize, repeat: 0)
            var itemStart: Int64 = 0
            var orgStart: Int64 = 0
            var index: Int64 = 0
            let data = unsafe { this.rawData() }
            let newArr: Array<UInt8> = unsafe { new.rawData() }
            for (i in 0..total) {
                index = unsafe { indexes.read(i) }
                itemArray[itemStart..(itemStart + index - orgStart)] = data[orgStart..index]
                itemStart += index - orgStart
                itemArray[itemStart..(itemStart + newSize)] = newArr
                itemStart += newSize
                orgStart = index + oldSize
            }
            itemArray[itemStart..(itemStart + size - orgStart)] = data[orgStart..]
            return String(itemArray)
        } finally {
            unsafe { LibC.free(res) }
        }
    }

    @Frozen
    @OverflowWrapping
    public func toAsciiLower(): String {
        let newRawPtr = RawArray<UInt8>(this.size, repeat: 0)
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in Int64(length) - 1..=0 : -1) {
            var c: UInt8 = arrayGetUnchecked(this.myData, i + Int64(start))
            if (ASCII_A <= c && c <= ASCII_Z) {
                arraySetUnchecked(newRawPtr, i, c + ASCII_UPPER_LOWER_DIFFERENCE)
            } else {
                arraySetUnchecked(newRawPtr, i, c)
            }
        }
        return String(newRawPtr, 0, length)
    }

    @Frozen
    @OverflowWrapping
    public func toAsciiUpper(): String {
        let newRawPtr = RawArray<UInt8>(this.size, repeat: 0)
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in Int64(length) - 1..=0 : -1) {
            var c: UInt8 = arrayGetUnchecked(this.myData, i + Int64(start))
            if (ASCII_a <= c && c <= ASCII_z) {
                arraySetUnchecked(newRawPtr, i, c - ASCII_UPPER_LOWER_DIFFERENCE)
            } else {
                arraySetUnchecked(newRawPtr, i, c)
            }
        }
        return String(newRawPtr, 0, length)
    }

    @Frozen
    @OverflowWrapping
    public func toAsciiTitle(): String {
        var i: Int64 = 0
        let newRawPtr = RawArray<UInt8>(this.size, repeat: 0)
        var next: Bool = true
        while (i < size) {
            var c: UInt8 = arrayGetUnchecked(this.myData, i + Int64(start))
            arraySetUnchecked(newRawPtr, i, c)
            if (ASCII_a <= c && c <= ASCII_z) {
                if (next) {
                    arraySetUnchecked(newRawPtr, i, c - ASCII_UPPER_LOWER_DIFFERENCE)
                    next = false
                }
            } else if (ASCII_A <= c && c <= ASCII_Z) {
                if (!next) {
                    arraySetUnchecked(newRawPtr, i, c + ASCII_UPPER_LOWER_DIFFERENCE)
                } else {
                    next = false
                }
            } else {
                next = true
            }
            i++
        }
        return String(newRawPtr, 0, length)
    }

    @Frozen
    public func trimAscii(): String {
        this.trimAsciiStart().trimAsciiEnd()
    }

    @Frozen
    @OverflowWrapping
    public func trimAsciiStart(): String {
        var start: Int64 = 0
        var foundFirst: Bool = false
        for (i in 0..size) {
            if (!arrayGetUnchecked(myData, i + Int64(this.start)).isAsciiWhiteSpace()) {
                start = i
                foundFirst = true
                break
            }
        }
        if (!foundFirst) {
            return String.empty
        }
        String(myData, this.start + UInt32(start), length - UInt32(start))
    }

    @Frozen
    @OverflowWrapping
    public func trimAsciiEnd(): String {
        var end: Int64 = size - 1
        var foundLast: Bool = false
        for (i in end..-1 : -1) {
            if (!arrayGetUnchecked(myData, i + Int64(this.start)).isAsciiWhiteSpace()) {
                end = i
                foundLast = true
                break
            }
        }
        if (!foundLast) {
            return String.empty
        }
        String(myData, this.start, UInt32(end) + 1)
    }

    @Frozen
    @OverflowWrapping
    public func trimStart(set: Array<Rune>): String {
        var start = Int64(this.start)
        let end = start + Int64(this.length)
        var trim = false
        while (start < end) {
            let (rune, utf8Size) = Rune.fromUtf8(myData, start, end)
            for (i in 0..set.size) {
                if (set[i] == rune) {
                    start += utf8Size
                    trim = true
                    break
                }
                trim = false
            }
            if (!trim) {
                return String(myData, UInt32(start), UInt32(end - start))
            }
        }
        return String.empty
    }

    @Frozen
    public func trimEnd(set: Array<Rune>): String {
        String(toRuneArray().trimEnd(set))
    }

    @Frozen
    public func trimStart(set: String): String {
        trimStart(set.toRuneArray())
    }

    @Frozen
    public func trimEnd(set: String): String {
        trimEnd(set.toRuneArray())
    }

    @Frozen
    public func trimStart(predicate: (Rune) -> Bool): String {
        var start = this.start
        var end = start + this.length
        while (start < end) {
            let (rune, utf8Size) = Rune.fromUtf8(myData, Int64(start), Int64(end))
            if (!predicate(rune)) {
                return String(myData, start, end - start)
            }
            start += UInt32(utf8Size)
        }
        return String.empty
    }

    @Frozen
    public func trimEnd(predicate: (Rune) -> Bool): String {
        return String(toRuneArray().trimEnd(predicate))
    }

    @Frozen
    public func removePrefix(prefix: String): String {
        if (this.startsWith(prefix)) {
            return this[prefix.size..]
        }
        return this
    }

    @Frozen
    public func removeSuffix(suffix: String): String {
        if (this.endsWith(suffix)) {
            return this[0..this.size - suffix.size]
        }
        return this
    }

    @Frozen
    public func contains(str: String): Bool {
        if (str.isEmpty()) {
            return true
        }
        match (this.indexOf(str)) {
            case None => false
            case _ => true
        }
    }

    // Returns true if and only if this string starts with the given `prefix`.
    @Frozen
    @OverflowWrapping
    public func startsWith(prefix: String): Bool {
        let strLen: Int64 = prefix.size
        if (strLen == 0) {
            return true
        }
        if (size < strLen) {
            return false
        }
        if (strLen < STRING_C_THRESHOLD) {
            for (i in 0..strLen) {
                if (arrayGetUnchecked(this.myData, Int64(start) + i) !=
                    arrayGetUnchecked(prefix.myData, Int64(prefix.start) + i)) {
                    return false
                }
            }
            return true
        }
        var res: Int64 = 0
        unsafe {
            var handle1: CPointer<UInt8> = acquireRawData<UInt8>(this.myData) + Int64(this.start)
            var handle2: CPointer<UInt8> = acquireRawData<UInt8>(prefix.myData) + Int64(prefix.start)
            res = CJ_CORE_StringMemcmp(handle1, handle2, UIntNative(strLen))
            releaseRawData<UInt8>(this.myData, handle1 - Int64(this.start))
            releaseRawData<UInt8>(prefix.myData, handle2 - Int64(prefix.start))
        }
        return res == 0
    }

    // Returns true if and only if this string ends with the given `suffix`.
    @Frozen
    @OverflowWrapping
    public func endsWith(suffix: String): Bool {
        let strLen: Int64 = suffix.size
        if (strLen == 0) {
            return true
        }
        if (size < strLen) {
            return false
        }
        let distance: Int64 = size - strLen
        if (strLen < STRING_C_THRESHOLD) {
            for (i in 0..strLen) {
                if (arrayGetUnchecked(this.myData, Int64(start) + distance + i) !=
                    arrayGetUnchecked(suffix.myData, Int64(suffix.start) + i)) {
                    return false
                }
            }
            return true
        }

        var res: Int64 = 0
        unsafe {
            var handle1: CPointer<UInt8> = acquireRawData<UInt8>(this.myData) + Int64(this.start)
            var handle2: CPointer<UInt8> = acquireRawData<UInt8>(suffix.myData) + Int64(suffix.start)
            res = CJ_CORE_StringMemcmp(handle1 + distance, handle2, UIntNative(strLen))
            releaseRawData<UInt8>(this.myData, handle1 - Int64(this.start))
            releaseRawData<UInt8>(suffix.myData, handle2 - Int64(suffix.start))
        }
        return res == 0
    }

    /**
     * @return a new string which is the result of padding zero or more `padding` to this string on the left.
     * @throws IllegalArgumentException if `totalWidth` < 0.
     */
    @Frozen
    public func padStart(totalWidth: Int64, padding!: String = " "): String {
        if (totalWidth < 0) {
            throw IllegalArgumentException("negative totalWidth")
        }
        if (totalWidth == 0 || this.size > totalWidth) {
            return this
        }
        let runeLen = padding.size
        let padLen: Int64 = (totalWidth - this.size + runeLen - 1) / runeLen
        var itemBytes: Array<UInt8> = Array<UInt8>(runeLen * padLen + size, repeat: 0)
        var k: Int64 = 0
        let paddingdata = unsafe { padding.rawData() }
        for (_ in 0..padLen) {
            itemBytes[k..(k + padding.size)] = paddingdata
            k += runeLen
        }
        itemBytes[k..(k + size)] = unsafe { this.rawData() }
        return String(itemBytes)
    }

    /**
     * @return a new string which is the result of padding zero or more `padding` to this string on the right.
     * @throws IllegalArgumentException if `totalWidth` < 0.
     */
    @Frozen
    public func padEnd(totalWidth: Int64, padding!: String = " "): String {
        if (totalWidth < 0) {
            throw IllegalArgumentException("negative totalWidth")
        }
        if (totalWidth == 0 || this.size > totalWidth) {
            return this
        }
        let runeLen = padding.size
        let padLen: Int64 = (totalWidth - this.size + runeLen - 1) / runeLen
        var itemBytes: Array<UInt8> = Array<UInt8>(runeLen * padLen + size, repeat: 0)
        itemBytes[..size] = unsafe { this.rawData() }
        var k: Int64 = size
        let paddingdata = unsafe { padding.rawData() }
        for (_ in 0..padLen) {
            itemBytes[k..(k + padding.size)] = paddingdata
            k += runeLen
        }
        return String(itemBytes)
    }

    @Frozen
    @OverflowWrapping
    public func equalsIgnoreAsciiCase(that: String): Bool {
        if (this.length != that.length) {
            return false
        }
        var idx1 = Int64(this.start)
        var idx2 = Int64(that.start)
        while (idx1 < Int64(this.start + this.length)) {
            let b1 = arrayGetUnchecked(this.myData, idx1)
            let b2 = arrayGetUnchecked(that.myData, idx2)
            if (!byteEqualsIgnoreAsciiCase(b1, b2)) {
                return false
            }
            idx1++
            idx2++
        }
        return true
    }

    @Frozen
    private func byteEqualsIgnoreAsciiCase(b1: Byte, b2: Byte): Bool {
        if (b1 == b2) {
            return true
        }
        // b1 in 'A' ~ 'Z', and the lower case of b1 equals to b2
        if (b1 >= b'A' && b1 <= b'Z' && (b1 + ASCII_UPPER_TO_LOWER_DIFF) == b2) {
            return true
        }
        if (b2 >= b'A' && b2 <= b'Z' && (b2 + ASCII_UPPER_TO_LOWER_DIFF) == b1) {
            return true
        }
        return false
    }

    // compare `num` bytes of ptr1[start1..] to ptr2[start2..],
    // returning zero if they are all equal
    // or a positive value representing ptr1[start1..] is greater
    @Frozen
    static const func compareBytes(ptr1: RawArray<Byte>, start1: Int64, ptr2: RawArray<Byte>, start2: Int64, num: Int64): Int64 {
        return if (IS_SIMD_SUPPORTED) {
            compareBytesFast(ptr1, start1, ptr2, start2, num)
        } else {
            compareBytesCommon(ptr1, start1, ptr2, start2, num)
        }
    }

    @Frozen
    @OverflowWrapping
    static const func compareBytesCommon(ptr1: RawArray<Byte>, start1: Int64,
                                    ptr2: RawArray<Byte>, start2: Int64, num: Int64): Int64 {
        var offset1 = start1
        var offset2 = start2
        for (_ in 0..num) {
            let b1 = arrayGetUnchecked(ptr1, offset1)
            let b2 = arrayGetUnchecked(ptr2, offset2)
            if (b1 != b2) {
                return if (b1 > b2) { 1 } else { -1 }
            }
            offset1++
            offset2++
        }
        return 0
    }

    @Frozen
    @OverflowWrapping
    static const func compareBytesFast(ptr1: RawArray<Byte>, start1: Int64,
                                    ptr2: RawArray<Byte>, start2: Int64, num: Int64): Int64 {
        var i = 0
        var offset1 = start1
        var offset2 = start2
        while (i + VECTOR_OFFSET_32 <= num) {
            let vecCmpRes: Int64 = vectorCompare32(ptr1, offset1, ptr2, offset2)
            // If any byte is not matched, return a value different from 32
            if (vecCmpRes != 32) {
                let b1 = arrayGetUnchecked(ptr1, offset1 + vecCmpRes)
                let b2 = arrayGetUnchecked(ptr2, offset2 + vecCmpRes)
                return if (b1 > b2) { 1 } else { -1 }
            }
            i += VECTOR_OFFSET_32
            offset1 += VECTOR_OFFSET_32
            offset2 += VECTOR_OFFSET_32
        }

        for (_ in i..num) {
            let b1 = arrayGetUnchecked(ptr1, offset1)
            let b2 = arrayGetUnchecked(ptr2, offset2)
            if (b2 != b1) {
                return if (b1 > b2) { 1 } else { -1 }
            }
            offset1++
            offset2++
        }
        return 0
    }

    /**
     * Compare the relationship between two instance of String, lexically byte-wise.
     *
     * @param str Instance of String compared with this.
     * @return Value indicating the relationship between two instance of String.
     *
     * @throws IllegalArgumentException if there is an invalid utf8 leading code
     *         in array `arr1` or `arr2`.
     *
     * @since 0.27.3
     */
    @Frozen
    public func compare(str: String): Ordering {
        var minSize: Int64 = if (this.size < str.size) {
            this.size
        } else {
            str.size
        }

        let res = compareBytes(this.myData, Int64(this.start), str.myData, Int64(str.start), minSize)

        if (res > 0) {
            return Ordering.GT
        } else if (res < 0) {
            return Ordering.LT
        }

        if (this.size > minSize) {
            return Ordering.GT
        } else if (str.size > minSize) {
            return Ordering.LT
        }

        return Ordering.EQ
    }

    // Return a string which is the result of concatenating `left` and `right`.
    @Frozen
    @OverflowWrapping
    public operator const func +(right: String): String {
        let newLen = this.size + right.size
        if (newLen > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }

        let newData = RawArray<Byte>(newLen, repeat: 0)
        intrinsicBuiltInCopyTo<UInt8>(this.myData, newData, Int64(this.start), 0, this.size)
        intrinsicBuiltInCopyTo<UInt8>(right.myData, newData, Int64(right.start), this.size, right.size)
        return String(newData, 0, UInt32(newLen))
    }

    @Frozen
    public operator const func *(count: Int64): String {
        if (count < 0) {
            throw IllegalArgumentException("Negative count.")
        }
        if (this.size == 0 || count == 0) {
            return String.empty
        }
        let newLen = this.size * count
        if (newLen > Int64(UInt32.Max)) {
            throw IllegalArgumentException("The size of String is too large.")
        }

        let newData = RawArray<Byte>(newLen, repeat: 0)
        var itemStart: Int64 = 0
        let byteSize: Int64 = size
        for (_ in 0..count) {
            intrinsicBuiltInCopyTo<UInt8>(this.myData, newData, Int64(this.start), itemStart, byteSize)
            itemStart += byteSize
        }
        return String(newData, 0, UInt32(newLen))
    }

    // Returns true if and only if string `left` is less than `right` with the lexicographical order.
    @Frozen
    public operator const func <(right: String): Bool {
        return match (this.compare(right)) {
            case LT => return true
            case _ => return false
        }
    }

    // Returns true if and only if string `left` is less than or equal to `right` with the lexicographical order.
    @Frozen
    public operator const func <=(right: String): Bool {
        return match (this.compare(right)) {
            case GT => return false
            case _ => return true
        }
    }

    // Returns true if and only if string `left` is greater than `right` with the lexicographical order.
    @Frozen
    public operator const func >(right: String): Bool {
        return match (this.compare(right)) {
            case GT => return true
            case _ => return false
        }
    }

    // Returns true if and only if string `left` is greater than or equal to `right` with the lexicographical order.
    @Frozen
    public operator const func >=(right: String): Bool {
        return match (this.compare(right)) {
            case LT => return false
            case _ => return true
        }
    }

    // Returns true if and only if the two string are identical.
    @Frozen
    public operator const func ==(right: String): Bool {
        if (this.length != right.length) {
            return false
        }
        if (intrinsicRefEqRawArray(this.myData, right.myData) && this.start == right.start) {
            return true
        }
        return compareBytes(this.myData, Int64(this.start), right.myData, Int64(right.start), Int64(this.length)) == 0
    }

    // Returns true if and only if the two string are not identical.
    @Frozen
    public operator const func !=(right: String): Bool {
        return !(this == right)
    }

    /**
     * @return the `Byte` value at the specified index.
     * @throws IndexOutOfBoundsException if `index` is out of bounds.
     */
    @Frozen
    @OverflowWrapping
    public operator const func [](index: Int64): Byte {
        if (index < 0 || index >= size) {
            throw IndexOutOfBoundsException("The length of the string is ${this.size}, but the index is ${index}.")
        }
        return arrayGetUnchecked(myData, index + Int64(start))
    }

    // Considering the performanceï¼Œthis method do not check the parameters.
    // Use this method only with valid parameters.
    @Frozen
    private func sliceUnchecked(startIndex: Int64, len: Int64) {
        return String(Array<Byte>(myData, Int64(this.start) + startIndex, len))
    }

    /**
     * @return the `String` value at the specified range.
     * @throws IllegalArgumentException if `step` is not equal to one.
     * @throws IndexOutOfBoundsException if `range` is out of bounds.
     * @throws IllegalArgumentException if the start or end point of the range is not the code point boundary.
     */
    @OverflowWrapping
    @Frozen
    public operator const func [](range: Range<Int64>): String {
        let start: Int64 = range.start
        var end: Int64 = range.end
        let step: Int64 = range.step
        let isClosed: Bool = range.isClosed

        if (step != 1) {
            throw IllegalArgumentException("the value of the step should be '1'")
        }

        if (isClosed) {
            end += 1
        }
        // If end is omitted, end = size of array.
        if (!range.hasEnd) {
            end = size
        }

        if (start < 0 || end < start || end > size) {
            throw IndexOutOfBoundsException("Invalid range start: ${start} or end: ${end}")
        }
        if (start < size && (arrayGetUnchecked(myData, start + Int64(this.start)) >> 6) == 0b10) {
            // 0b10 means the start position is not the code point boundary
            throw IllegalArgumentException("Invalid utf8 byte sequence.")
        }
        if (end < size && (arrayGetUnchecked(myData, end + Int64(this.start)) >> 6) == 0b10) {
            // 0b10 means the end position is not the code point boundary
            throw IllegalArgumentException("Invalid utf8 byte sequence.")
        }
        if (end - start == 0) {
            return String.empty
        }
        return sliceUnchecked(start, end - start)
    }

    @Frozen
    @OverflowWrapping
    public static func join(strArray: Array<String>, delimiter!: String = String.empty): String {
        let strArraySize: Int64 = strArray.size
        if (strArraySize == 0) {
            return String.empty
        }
        var sizeOfBytes: Int64 = 0
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in strArraySize - 1..=0 : -1) {
            sizeOfBytes += strArray[i].size
        }
        sizeOfBytes += delimiter.size * (strArraySize - 1)
        if (sizeOfBytes == 0) {
            return String.empty
        } else if (sizeOfBytes > Int64(Int32.Max)) {
            throw IllegalArgumentException("The size of target string is too large.")
        }

        let delimiterBytes: Array<UInt8> = unsafe { delimiter.rawData() }
        let sizeOfDelimiterByte: Int64 = delimiterBytes.size
        let bytes: Array<UInt8> = Array<UInt8>(sizeOfBytes, repeat: 0)
        var cursor: Int64 = 0
        // Concatenate strings and delimiters except the last string
        for (i in 0..(strArraySize - 1)) {
            let sz: Int64 = strArray[i].size
            bytes[cursor..(cursor + sz)] = unsafe { strArray[i].rawData() }
            cursor += sz
            // Append the delimiter
            bytes[cursor..(cursor + sizeOfDelimiterByte)] = delimiterBytes
            cursor += sizeOfDelimiterByte
        }
        // Append the last string
        let lastStr: String = strArray[strArraySize - 1]
        bytes[cursor..(cursor + lastStr.size)] = unsafe { lastStr.rawData() }
        return String(bytes)
    }

    @Frozen
    @OverflowWrapping
    private func indexOfString(str: String, startIndex!: Int64 = 0, fromLast!: Bool = false): Int64 {
        var index: Int64 = -1
        let strSize: Int64 = str.size
        if (strSize == 0 || strSize > this.size) {
            return index
        }
        unsafe {
            var org: CPointer<UInt8> = acquireRawData<UInt8>(this.myData) + Int64(this.start)
            var pat: CPointer<UInt8> = acquireRawData<UInt8>(str.myData) + Int64(str.start)
            if (fromLast) {
                index = CJ_CORE_LastIndexOfString(org, pat, size, strSize, startIndex)
            } else {
                index = CJ_CORE_IndexOfString(org, pat, size, strSize, startIndex)
            }
            releaseRawData<UInt8>(this.myData, org - Int64(this.start))
            releaseRawData<UInt8>(str.myData, pat - Int64(str.start))
        }
        return index
    }

    /**
     * @throws OutOfMemoryError if failed to call CJ_CORE_CountAndIndexString.
     */
    @Frozen
    @OverflowWrapping
    private func splitOfString(str: String, maxSplits: Int64, removeEmpty: Bool): Array<String> {
        let strLen: Int64 = str.size
        if (strLen == 0) {
            return this.splitOfStringForOneRune(maxSplits)
        }

        var res: CPointer<Int64> = CPointer<Int64>()
        var indexes: CPointer<Int64> = CPointer<Int64>()
        var total: Int64 = 0
        unsafe {
            let org: CPointer<UInt8> = acquireRawData(this.myData) + Int64(this.start)
            let pat: CPointer<UInt8> = acquireRawData(str.myData) + Int64(str.start)
            res = CJ_CORE_CountAndIndexString(org, pat, size, strLen)
            if (res.isNull()) {
                releaseRawData(this.myData, org - Int64(this.start))
                releaseRawData(str.myData, pat - Int64(str.start))
                throw OutOfMemoryError("Failed malloc in C code!")
            }
            total = res.read(0)
            indexes = res + 1
            releaseRawData(this.myData, org - Int64(this.start))
            releaseRawData(str.myData, pat - Int64(str.start))
        }
        if (total == 0) {
            unsafe { LibC.free(res) }
            return [this]
        }
        try {
            return splitAsStringArray(indexes, total, strLen, maxSplits, removeEmpty)
        } finally {
            unsafe { LibC.free(res) }
        }
    }

    /**
     * @throws IllegalArgumentException if there is an invalid utf8 leading code
     *         in array `this.myData`.
     */
    @Frozen
    @OverflowWrapping
    private func splitOfStringForOneRune(maxSplits: Int64): Array<String> {
        let resLen = if (0 < maxSplits && maxSplits < size) {
            maxSplits
        } else {
            size
        }
        let resArr: Array<String> = Array<String>(resLen, repeat: unsafe { zeroValue<String>() })
        var i: Int64 = 0
        var index: Int64 = 0
        var itemStart: Int64 = 0
        while (index < resLen && i < size) {
            if (index == resLen - 1) {
                resArr[index] = String(this.myData, UInt32(itemStart) + start, length - UInt32(itemStart))
                index++
                break
            }
            let byte = arrayGetUnchecked(myData, i + Int64(start))
            let oneCharLen = if (byte.isAscii()) {
                1
            } else {
                Rune.utf8SizeUnchecked(byte)
            }
            resArr[index] = sliceUnchecked(itemStart, oneCharLen)
            itemStart += oneCharLen
            i += oneCharLen
            index++
        }
        return resArr[..index]
    }

    @Frozen
    private func getRealSplitLenWithRemoveEmpty(indexes: CPointer<Int64>, total: Int64, separatorLen: Int64) {
        var itemTotal: Int64 = 0
        var itemStart: Int64 = 0
        var i: Int64 = 0
        while (i < total) {
            var index = unsafe { indexes.read(i) }
            i++
            if (itemStart == index) {
                itemStart = index + separatorLen
                continue
            }
            itemStart = index + separatorLen
            itemTotal++
        }
        if (itemStart != size) {
            itemTotal++
        }
        return itemTotal
    }

    @Frozen
    @OverflowWrapping
    private func splitAsStringArray(
        indexes: CPointer<Int64>,
        total: Int64,
        separatorLen: Int64,
        maxSplits: Int64,
        removeEmpty: Bool
    ): Array<String> {
        var itemTotal: Int64 = if (removeEmpty) {
            getRealSplitLenWithRemoveEmpty(indexes, total, separatorLen)
        } else {
            total + 1
        }
        var resLen: Int64 = if (0 < maxSplits && maxSplits < itemTotal) {
            maxSplits
        } else {
            itemTotal
        }
        if (resLen == 0) {
            return Array<String>()
        }
        if (maxSplits == 1) {
            return [this]
        }
        let resArr: Array<String> = Array<String>(resLen, repeat: String.empty)
        var (i, j, itemStart, index, resStr) = (0, 0, 0, 0, String.empty)
        while (j < resLen - 1) {
            index = unsafe { indexes.read(i) }
            i++
            if (removeEmpty && itemStart == index) {
                itemStart = index + separatorLen
                continue
            }
            resStr = String(this.myData, UInt32(itemStart) + start, UInt32(index) - UInt32(itemStart))
            resArr[j] = resStr
            j++
            itemStart = index + separatorLen
        }
        // Special Processing Last String
        if (removeEmpty && i < total) {
            while (i < total) {
                index = unsafe { indexes.read(i) }
                i++
                if (itemStart == index) {
                    itemStart = index + separatorLen
                    continue
                }
                break
            }
            if (itemStart > index || (maxSplits > 0 && resLen != itemTotal)) {
                index = size
            }
            resArr[j] = String(this.myData, UInt32(itemStart) + start, UInt32(index) - UInt32(itemStart))
            return resArr
        }
        resArr[j] = String(this.myData, UInt32(itemStart) + start, length - UInt32(itemStart))
        return resArr
    }
}

@When[backend == "cjnative"]
@OverflowWrapping
func utf8RuneSize(arr: RawArray<UInt8>, start: Int64, length: Int64): Int64 {
    if (length < STRING_C_THRESHOLD) {
        var utf32Size = 0
        for (i in length - 1..=0 : -1) {
            if ((arrayGet<UInt8>(arr, start + i) & 0xC0) != 0x80) {
                utf32Size++
            }
        }
        return utf32Size
    }

    unsafe {
        let pointer: CPointer<UInt8> = acquireRawData<UInt8>(arr) + start
        let utf32Size = CJ_CORE_StringSize(pointer, length)
        releaseRawData(arr, pointer - start)
        return utf32Size
    }
}

@When[backend == "cjnative"]
struct RunesToUtf8Bytes {
    @OverflowWrapping
    public static func getBytes(runes: Array<Rune>): Array<UInt8> {
        var itemBytes: Array<UInt8> = Array<UInt8>(getSize(runes), repeat: 0)
        var itemLen: Int64 = 0
        for (i in 0..runes.size) {
            let r = runes[i]
            if (r.isAscii()) {
                itemBytes[itemLen] = UInt8(UInt32(r))
                itemLen++
            } else {
                itemLen += Rune.intoUtf8Array(r, itemBytes, itemLen)
            }
        }
        return itemBytes
    }

    @OverflowWrapping
    public static func getBytes(elements: Collection<Rune>): Array<UInt8> {
        let itemBytes: Array<UInt8> = Array<UInt8>(UNICODE_TO_UTF8_MAX_LEN * elements.size, repeat: 0)
        var itemLen: Int64 = 0
        let it = elements.iterator()
        while (true) {
            var c: Rune = match (it.next()) {
                case Some(v) => v
                case None => break
            }
            itemLen += Rune.intoUtf8Array(c, itemBytes, itemLen)
        }
        var bytes: Array<UInt8> = Array<UInt8>(itemLen, repeat: 0)
        bytes[..itemLen] = itemBytes[..itemLen]
        return bytes
    }

    @OverflowWrapping
    public static func getSize(runes: Array<Rune>): Int64 {
        var size: Int64 = 0
        /* Back-to-front traversal can reduce boundary checks and improve performance */
        for (i in runes.size - 1..=0 : -1) {
            size += Rune.utf8Size(runes[i])
        }
        return size
    }
}
